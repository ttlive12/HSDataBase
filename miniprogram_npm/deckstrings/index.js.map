{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.deckstrings = {})));\n}(this, (function (exports) { \n\nvar encode_1 = encode;\n\nvar MSB = 0x80;\nvar REST = 0x7F;\nvar MSBALL = ~REST;\nvar INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80;\nvar REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nfunction __extends(d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/** @internal */\nfunction atob_binary(encoded) {\n    return Buffer.from(encoded, \"base64\").toString(\"binary\");\n}\n/** @internal */\nfunction btoa_binary(decoded) {\n    return Buffer.from(decoded.toString(), \"binary\").toString(\"base64\");\n}\n\n/** @internal */\nvar Iterator = /** @class */ (function () {\n    function Iterator() {\n        this.index = 0;\n    }\n    Iterator.prototype.next = function (repeat) {\n        if (repeat === void 0) { repeat = 1; }\n        this.index += repeat;\n    };\n    return Iterator;\n}());\n/** @internal */\nvar BufferWriter = /** @class */ (function (_super) {\n    __extends(BufferWriter, _super);\n    function BufferWriter() {\n        var _this = _super.call(this) || this;\n        _this.buffer = [];\n        return _this;\n    }\n    BufferWriter.prototype.null = function () {\n        this.buffer[this.index] = 0;\n        this.next();\n    };\n    BufferWriter.prototype.varint = function (value) {\n        varint.encode(value, this.buffer, this.index);\n        this.next(varint.encode.bytes);\n    };\n    BufferWriter.prototype.toString = function () {\n        var binary = String.fromCharCode.apply(String, this.buffer);\n        return btoa_binary(binary);\n    };\n    return BufferWriter;\n}(Iterator));\n/** @internal */\nvar BufferReader = /** @class */ (function (_super) {\n    __extends(BufferReader, _super);\n    function BufferReader(string) {\n        var _this = _super.call(this) || this;\n        var binary = atob_binary(string);\n        var buffer = new Uint8Array(binary.length);\n        for (var i = 0; i < binary.length; i++) {\n            buffer[i] = binary.charCodeAt(i);\n        }\n        _this.buffer = buffer;\n        return _this;\n    }\n    BufferReader.prototype.nextByte = function () {\n        var value = this.buffer[this.index];\n        this.next();\n        return value;\n    };\n    BufferReader.prototype.nextVarint = function () {\n        var value = varint.decode(this.buffer, this.index);\n        this.next(varint.decode.bytes);\n        return value;\n    };\n    return BufferReader;\n}(Iterator));\n\nvar DECKSTRING_VERSION = 1;\nvar FormatType = {\n    FT_WILD: 1,\n    FT_STANDARD: 2,\n    FT_CLASSIC: 3,\n    FT_TWIST: 4,\n};\n\nfunction verifyDbfId(id, name) {\n    name = name ? name : \"dbf id\";\n    if (!isPositiveNaturalNumber(id)) {\n        throw new Error(\"Invalid \" + name + \" \" + id + \" (expected valid dbf id)\");\n    }\n}\nfunction isPositiveNaturalNumber(n) {\n    if (typeof n !== \"number\" || !isFinite(n)) {\n        return false;\n    }\n    if (Math.floor(n) !== n) {\n        return false;\n    }\n    return n > 0;\n}\nfunction sort_cards(cards, sideboard) {\n    if (sideboard === void 0) { sideboard = false; }\n    if (sideboard) {\n        return cards.sort(function (a, b) { return a[2] - b[2] || a[0] - b[0]; }) || 0;\n    }\n    return cards.sort(function (a, b) { return a[0] - b[0] || 0; });\n}\nfunction trisort_cards(cards) {\n    var single = [], double = [], n = [];\n    for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {\n        var tuple = cards_1[_i];\n        var card = tuple[0], count = tuple[1];\n        if (count === 0) {\n            continue;\n        }\n        if (count === 1) {\n            single.push(tuple);\n        }\n        else if (count === 2) {\n            double.push(tuple);\n        }\n        else if (isPositiveNaturalNumber(count)) {\n            n.push(tuple);\n        }\n        else {\n            throw new Error(\"Invalid count \" + count + \" (expected positive natural number)\");\n        }\n    }\n    return [single, double, n];\n}\nfunction encode$1(deck) {\n    if (typeof deck !== \"object\" ||\n        (deck.format !== FormatType.FT_WILD &&\n            deck.format !== FormatType.FT_STANDARD &&\n            deck.format !== FormatType.FT_CLASSIC &&\n            deck.format !== FormatType.FT_TWIST) ||\n        !Array.isArray(deck.heroes) ||\n        !Array.isArray(deck.cards) ||\n        (typeof deck.sideboardCards !== \"undefined\" &&\n            !Array.isArray(deck.sideboardCards))) {\n        throw new Error(\"Invalid deck definition\");\n    }\n    var writer = new BufferWriter();\n    var format = deck.format;\n    var heroes = deck.heroes.slice().sort();\n    var cards = sort_cards(deck.cards.slice());\n    var sideboard = sort_cards((deck.sideboardCards || []).slice(), true);\n    writer.null();\n    writer.varint(DECKSTRING_VERSION);\n    writer.varint(format);\n    writer.varint(heroes.length);\n    for (var _i = 0, heroes_1 = heroes; _i < heroes_1.length; _i++) {\n        var hero = heroes_1[_i];\n        verifyDbfId(hero, \"hero\");\n        writer.varint(hero);\n    }\n    for (var _a = 0, _b = trisort_cards(cards); _a < _b.length; _a++) {\n        var list = _b[_a];\n        writer.varint(list.length);\n        for (var _c = 0, list_1 = list; _c < list_1.length; _c++) {\n            var tuple = list_1[_c];\n            var card = tuple[0], count = tuple[1];\n            verifyDbfId(card), \"card\";\n            writer.varint(card);\n            if (count !== 1 && count !== 2) {\n                writer.varint(count);\n            }\n        }\n    }\n    if (sideboard.length) {\n        writer.varint(1);\n        for (var _d = 0, _e = trisort_cards(sideboard); _d < _e.length; _d++) {\n            var list = _e[_d];\n            writer.varint(list.length);\n            for (var _f = 0, list_2 = list; _f < list_2.length; _f++) {\n                var tuple = list_2[_f];\n                var card = tuple[0], count = tuple[1], owner = tuple[2];\n                verifyDbfId(card, \"sideboard card\");\n                verifyDbfId(owner, \"sideboard card owner\");\n                writer.varint(card);\n                if (count !== 1 && count !== 2) {\n                    writer.varint(count);\n                }\n                writer.varint(owner);\n            }\n        }\n    }\n    else {\n        writer.varint(0);\n    }\n    return writer.toString();\n}\nfunction decode$2(deckstring) {\n    var reader = new BufferReader(deckstring);\n    if (reader.nextByte() !== 0) {\n        throw new Error(\"Invalid deckstring\");\n    }\n    var version = reader.nextByte();\n    if (version !== DECKSTRING_VERSION) {\n        throw new Error(\"Unsupported deckstring version \" + version);\n    }\n    var format = reader.nextVarint();\n    if (format !== FormatType.FT_WILD &&\n        format !== FormatType.FT_STANDARD &&\n        format !== FormatType.FT_CLASSIC &&\n        format !== FormatType.FT_TWIST) {\n        throw new Error(\"Unsupported format \" + format + \" in deckstring\");\n    }\n    var heroes = new Array(reader.nextVarint());\n    for (var i = 0; i < heroes.length; i++) {\n        heroes[i] = reader.nextVarint();\n    }\n    heroes.sort();\n    var cards = [];\n    for (var i = 1; i <= 3; i++) {\n        for (var j = 0, c = reader.nextVarint(); j < c; j++) {\n            cards.push([\n                reader.nextVarint(),\n                i === 1 || i === 2 ? i : reader.nextVarint(),\n            ]);\n        }\n    }\n    sort_cards(cards);\n    var sideboardCards = [];\n    var hasSideboard = reader.nextByte();\n    if (hasSideboard == 1) {\n        for (var i = 1; i <= 3; i++) {\n            for (var j = 0, c = reader.nextVarint(); j < c; j++) {\n                sideboardCards.push([\n                    reader.nextVarint(),\n                    i === 1 || i === 2 ? i : reader.nextVarint(),\n                    reader.nextVarint(),\n                ]);\n            }\n        }\n        sort_cards(sideboardCards, true);\n    }\n    return {\n        cards: cards,\n        sideboardCards: sideboardCards,\n        heroes: heroes,\n        format: format,\n    };\n}\n\nexports.encode = encode$1;\nexports.decode = decode$2;\nexports.FormatType = FormatType;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}